"""Tarea 3 IA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XwVgy5_Bl_8HinspoNbfoGOzTmHQBB-s

@author: Matías Ramírez, Matías González
"""

#!pip install deap

#from google.colab import drive
#drive.mount('/content/drive')

import pandas as pd
import numpy as np
from io import StringIO
from deap import base, creator, tools, algorithms

file_path = 'C:\\Users\\Matia\\Downloads\\vrptw_c101.txt'

with open(file_path, 'r') as file:
    data = file.read()

data_relevant = data.split('SERVICE TIME\n')[1]
data_stream = StringIO(data_relevant)  


df = pd.read_csv(data_stream, sep="\s+", header=None)
df.columns = ["CUST NO.", "XCOORD.", "YCOORD.", "DEMAND", "READY TIME", "DUE DATE", "SERVICE TIME"]

df.head()

df.info()

from scipy.spatial.distance import pdist, squareform

coordinates = df[["XCOORD.", "YCOORD."]].to_numpy()
distances = pdist(coordinates, metric='euclidean')
adjacency_matrix = squareform(distances)

adjacency_df = pd.DataFrame(adjacency_matrix, index=df["CUST NO."], columns=df["CUST NO."])
adjacency_df  

def establecerParametros():
    params = {
        "population_size": 10,
        "max_generations": 10,
        "max_pareto_points": 50,
        "crossover_rate": 1.0,
        "mutation_rate": 0.2,
        "selection_method": "tournament",
        "vehicle_capacity": 200,
        "num_customers": 100,
        "service_times": df["SERVICE TIME"].to_list(),
        "time_windows": df[["READY TIME", "DUE DATE"]].values,
        "distance_matrix": adjacency_matrix
    }
    return params

import random

def generarPoblacionInicial(params):
    population = []
    for _ in range(params["population_size"]):
        individual = createRandomSolution(params)
        population.append(individual)
    return population

def createRandomSolution(params):
    all_customers = list(range(1, params["num_customers"]))
    random.shuffle(all_customers)

    routes = []
    current_route = []
    current_capacity = 0
    current_time = 0
    time_window_violations = 0

    for customer in all_customers:
        demand = df.loc[customer, "DEMAND"]
        ready_time, due_time = df.loc[customer, ["READY TIME", "DUE DATE"]]

        if current_route:
            last_customer = current_route[-1]
            travel_time = params['distance_matrix'][last_customer][customer]
            current_time += travel_time

        if current_time < ready_time:
            current_time = ready_time 
        if current_time > due_time:
            time_window_violations += 1

        if current_capacity + demand <= params["vehicle_capacity"]:
            current_route.append(customer)
            current_capacity += demand
            current_time += df.loc[customer, "SERVICE TIME"]
        else:
            routes.append(current_route)
            current_route = [customer]
            current_capacity = demand
            current_time = 0

    if current_route:
        routes.append(current_route)

    individual = {
        "routes": routes,
        "time_window_violations": time_window_violations
    }
    return individual

def condicion_de_parada_satisfecha(generation, max_generations, start_time, max_time):
    if generation >= max_generations:
        return True

    if ((datetime.now() - start_time).seconds) > max_time:
        return True

    return False

def evaluarIndividuos(population, paretoSet, params):
        fitness = FitnessAssignment(population, paretoSet)


def CollectNondominatedSolutions(population):
    pareto_set = []
    i = 0

    for individual in population:
        num_vehicles = len(individual['routes'])  
        time_window_violations = individual['time_window_violations']  
        is_dominated = False

        for other_individual in population:
            other_num_vehicles = len(other_individual['routes'])
            other_time_window_violations = other_individual['time_window_violations']

            if (other_num_vehicles <= num_vehicles and other_time_window_violations <= time_window_violations) and (other_num_vehicles < num_vehicles or other_time_window_violations < time_window_violations):
                is_dominated = True
                break

        if not is_dominated:
            pareto_set.append((num_vehicles, time_window_violations, i))
        i = i+1

    return pareto_set

def CombineParetoSets(A, B):
    for element in B:
        A.append(element)
    return A

def Covers(indA, indB):
        num_vehicles = indA[0] 
        time_window_violations = indA[1] 
        is_dominated = False
        other_num_vehicles = indB[0]
        other_time_window_violations = indB[1]

        if (other_num_vehicles <= num_vehicles and other_time_window_violations <= time_window_violations) and (other_num_vehicles < num_vehicles or other_time_window_violations < time_window_violations):
            return True
        else:
          return False

def SetFitness(individual, strength):
    if isinstance(individual, tuple):
        return individual + (strength,)
    elif isinstance(individual, dict):
        individual['fitness'] = strength
        return individual
    else:
        raise TypeError("Individual must be a tuple or a dictionary")
    
def GetFitness(individual):
    try:
        return individual[2]
    except IndexError:
        return 0


def FitnessAssignment(population, paretoSet):
    A = CollectNondominatedSolutions(population)
    B = CombineParetoSets(paretoSet, A)
    if len(B) > 10:
        paretoSet = ReduceParetoSet(B)
    else:
        paretoSet = B

    for paretoInd in paretoSet:
        strength = sum(1 for popInd in population if Covers(paretoInd, (len(popInd['routes']),popInd['time_window_violations']))) / (len(population) + 1)
        SetFitness(paretoInd, strength)

    for popInd in population:
        sum_fitness = sum(GetFitness(paretoInd) for paretoInd in paretoSet if Covers(paretoInd, (len(popInd['routes']),popInd['time_window_violations'])))
        SetFitness(popInd, sum_fitness + 1)

def actualizarConjuntoPareto(poblacion):
    pass

def findTwoClosestClusters(clusterSet):
    min_distance = float('inf')
    closest_pair = (None, None)

    for cluster1 in clusterSet:
        for cluster2 in clusterSet:
            if cluster1 != cluster2:
                distance = euclideanDistance(GetCentroid(cluster1), GetCentroid(cluster2))
                if distance < min_distance:
                    min_distance = distance
                    closest_pair = (cluster1, cluster2)

    return closest_pair[0], closest_pair[1], min_distance

def euclideanDistance(point1, point2):
    return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5

def ReduceParetoSet(paretoSet):
    clusterSet = [{((paretoInd[0]),paretoInd[1],paretoInd[2])} for paretoInd in paretoSet]
    while len(clusterSet) > 10:
        cluster1, cluster2, minDistance = findTwoClosestClusters(clusterSet)

        newCluster = cluster1.union(cluster2)
        clusterSet.remove(cluster1)
        clusterSet.remove(cluster2)
        clusterSet.append(newCluster)

    newParetoSet = set()
    for cluster in clusterSet:
        centroid = GetCentroid(cluster)
        newParetoSet.add(centroid)

    return newParetoSet

def selectParents(population):
    parent1 = binaryTournamentSelection(population)
    parent2 = binaryTournamentSelection(population)

    return parent1, parent2

def binaryTournamentSelection(population):
    individual1 = random.choice(population)
    individual2 = random.choice(population)

    if individual1['fitness'] < individual2['fitness']: 
        return individual1
    else:
        return individual2

def crossover(parent1, parent2):
    child = {'routes': []}

    min_route_length = min(len(parent1['routes']), len(parent2['routes']))
    if min_route_length == 0:
        return child

    route_index = random.randint(0, min_route_length - 1)

    if len(parent1['routes'][route_index]) < 2:
        child_route = parent1['routes'][route_index].copy()
    else:
        start, end = sorted(random.sample(range(len(parent1['routes'][route_index])), 2))
        child_route = parent1['routes'][route_index][start:end]

        for customer in parent2['routes'][route_index]:
            if customer not in child_route:
                child_route.append(customer)

    child['routes'].append(child_route)

    return child


def mutate(individual):
    mutated_individual = individual.copy() 
    route_index = random.randint(0, len(mutated_individual['routes']) - 1)
    route = mutated_individual['routes'][route_index]

    if len(route) >= 2:
        swap_indices = random.sample(range(len(route)), 2)
        route[swap_indices[0]], route[swap_indices[1]] = route[swap_indices[1]], route[swap_indices[0]]

    return mutated_individual

def aplicarOperadoresGeneticos(population, params):
    new_population = []

    while len(new_population) < len(population):
        parent1, parent2 = selectParents(population)

        offspring = crossover(parent1, parent2)

        offspring = mutate(offspring)

        new_population.extend(offspring)

    return new_population[:len(population)]

def GetCentroid(cluster):
    if not cluster:
        return None

    total_vehicles = 0
    total_time_window_violations = 0
    num_solutions = len(cluster)

    for solution in iter(cluster):
        total_vehicles += solution[0]
        total_time_window_violations += solution[1]

    centroid_num_vehicles = total_vehicles / num_solutions
    centroid_time_window_violations = total_time_window_violations / num_solutions

    return (centroid_num_vehicles, centroid_time_window_violations)

from datetime import datetime

def initializeExternalParetoSet(poblacion):
    externalParetoSet = []
    
    i = 0

    for individual in poblacion:
        num_vehicles = len(individual['routes'])
        time_window_violations = individual['time_window_violations']
        externalParetoSet.append((num_vehicles, time_window_violations,i))
        i = i + 1

    return externalParetoSet


def SPEA():
    params = establecerParametros()
    poblacion = generarPoblacionInicial(params)
    externalParetoSet = initializeExternalParetoSet(poblacion)
    generation = 0
    start_time = datetime.now()
    max_time = 100 # in seconds
    print(externalParetoSet)
    while not condicion_de_parada_satisfecha(generation, params["max_generations"], start_time, max_time):
        evaluarIndividuos(poblacion, externalParetoSet, params)
        aplicarOperadoresGeneticos(poblacion, params)
        generation = generation + 1
        
    for _, _, index in externalParetoSet:
        print(poblacion[index])


SPEA()
import pandas as pd
import matplotlib.pyplot as plt


# Creating a DataFrame from the array of tuples
df = pd.DataFrame( columns=['X', 'Y',z])
    for _, _, index in externalParetoSet:
        df.add(poblacion[index])

# Plotting the data
# Line plot
plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 1)
df.plot(x='Num Vehicles', y='Time Window Violations', title='Line Plot', ax=plt.gca())

# Scatter plot
plt.subplot(1, 2, 2)
df.plot.scatter(x='Num Vehicles', y='Time Window Violations', title='Scatter Plot', ax=plt.gca())

plt.tight_layout()
plt.show()
